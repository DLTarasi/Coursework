new_crime = predict(object=cv_fit, newx = test_city)
new_crime
lassopred<-predict(object=cv_fit,  s=cv_fit$lambda.min, newx=x.test)
lassopred
R2lasso <- 1 - (sum((y.test-lassopred )^2)/sum((y.test-mean(lassopred))^2))
R2lasso
lassopred<-predict(object=lasso,  s=cv_fit$lambda.min, newx=x.test)
#create table of crime data with headers
uscrimedata<-read.table("uscrime.txt", header = TRUE)
#split into input and response vars
x<-uscrimedata[,1:15]
y<-uscrimedata[,16]
#split into training and test set
set.seed(1)
spec = c(train = .8, test = .2)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
#convert each input and response training and test set into matrices
x.train <- as.matrix(x$train)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.test <- as.matrix(y$test)
########Build Model
lasso <- glmnet(x.train, y.train, family="mgaussian", alpha=1)
cv_fit <- cv.glmnet(x.train, y.train, alpha = 1)
plot(cv_fit)
########Predict
#create test city data frame
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
test_city <- t(test_city)
#predict crime level in test city
new_crime = predict(object=cv_fit, newx = test_city)
new_crime
lassopred<-predict(object=cv_fit,  s=cv_fit$lambda.min, newx=x.test)
lassopred
R2lasso <- 1 - (sum((y.test-lassopred )^2)/sum((y.test-mean(lassopred))^2))
R2lasso
#packages
library(glmnet)
library(ggplot2)
library(reshape2)
#set Directory to data path
setwd('/Users/dave/isye6501/Week_8')
#create table of crime data with headers
uscrimedata<-read.table("uscrime.txt", header = TRUE)
#Check class and inspect data
class(uscrimedata)
head(uscrimedata)
summary(uscrimedata)
#####Plotting and Data Cleaning
#####Outlier Testing - did not remove potential outliers based on week three analysis
#plot all variables
uscrime_melt = melt(data=uscrimedata, measure.vars = colnames(uscrimedata[,1:15]))
ggplot(data = uscrime_melt, aes(x=value, y=Crime)) +
geom_point() +
facet_wrap(~variable, scales = "free")
#convert to matrix for use with glm
x<-uscrimedata[,1:15]
y<-uscrimedata[,16]
#Scale Data
uscrimedata <- as.data.frame(scale(uscrimedata))
#split into training and test set
set.seed(1)
spec = c(train = .8, test = .2)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
x.train <- as.matrix(x$train)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.test <- as.matrix(y$test)
########Build Model
?glmnet
#base elastic net
elnet <- glmnet(x.train, y.train, family="mgaussian", alpha=.5, standardize = TRUE)
plot(elnet)
plot(fit5)
#base elastic net
elnet <- glmnet(x.train, y.train, family="mgaussian", alpha=.5, standardize = TRUE)
#ridge
ridge <- glmnet(x.train, y.train, family="mgaussian", alpha=0, standardize = TRUE)
# Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
for (i in 0:10) {
assign(paste("fit", i, sep=""), cv.glmnet(x.train, y.train, type.measure="mse",
alpha=i/10,family="gaussian"))
}
yhat0 <- predict(fit0, s=fit0$lambda.min, newx=x.test)
yhat1 <- predict(fit1, s=fit1$lambda.min, newx=x.test)
yhat2 <- predict(fit2, s=fit2$lambda.min, newx=x.test)
yhat3 <- predict(fit3, s=fit3$lambda.min, newx=x.test)
yhat4 <- predict(fit4, s=fit4$lambda.min, newx=x.test)
yhat5 <- predict(fit5, s=fit5$lambda.min, newx=x.test)
yhat6 <- predict(fit6, s=fit6$lambda.min, newx=x.test)
yhat7 <- predict(fit7, s=fit7$lambda.min, newx=x.test)
yhat8 <- predict(fit8, s=fit8$lambda.min, newx=x.test)
yhat9 <- predict(fit9, s=fit9$lambda.min, newx=x.test)
yhat10 <- predict(fit10, s=fit10$lambda.min, newx=x.test)
mse0 <- mean((y.test - yhat0)^2)
mse1 <- mean((y.test - yhat1)^2)
mse2 <- mean((y.test - yhat2)^2)
mse3 <- mean((y.test - yhat3)^2)
mse4 <- mean((y.test - yhat4)^2)
mse5 <- mean((y.test - yhat5)^2)
mse6 <- mean((y.test - yhat6)^2)
mse7 <- mean((y.test - yhat7)^2)
mse8 <- mean((y.test - yhat8)^2)
mse9 <- mean((y.test - yhat9)^2)
mse10 <- mean((y.test - yhat10)^2)
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10))
plot(fit5)
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10))
plot(fit5, yscale=0,10000)
?plot
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10))
plot(fit5, ylab = "MSE")
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10))
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE")
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit0)
plot(fit1)
plot(fit0)
plot(fit10)
plot(fit5)
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit4)
mse4 <- mean((y.test - yhat4)^2)
plot(c(mse0,mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(c(mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit4)
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
#predict crime level in test city
new_crime = predict(fit4, s=fit4$lambda.min, newx=test_city)
new_crime
elpred<-predict(fit4, s=fit4$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
test_city <-t(test_city)
#predict crime level in test city
new_crime = predict(fit4, s=fit4$lambda.min, newx=test_city)
new_crime
elpred<-predict(fit4, s=fit4$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
#packages
library(glmnet)
library(ggplot2)
library(reshape2)
#set Directory to data path
setwd('/Users/dave/isye6501/Week_8')
#create table of crime data with headers
uscrimedata<-read.table("uscrime.txt", header = TRUE)
#Check class and inspect data
class(uscrimedata)
head(uscrimedata)
summary(uscrimedata)
#####Plotting and Data Cleaning
#####Outlier Testing - did not remove potential outliers based on week three analysis
#plot all variables
uscrime_melt = melt(data=uscrimedata, measure.vars = colnames(uscrimedata[,1:15]))
ggplot(data = uscrime_melt, aes(x=value, y=Crime)) +
geom_point() +
facet_wrap(~variable, scales = "free")
#convert to matrix for use with glm
x<-uscrimedata[,1:15]
y<-uscrimedata[,16]
#Scale Data
uscrimedata <- as.data.frame(scale(uscrimedata))
#split into training and test set
set.seed(1)
spec = c(train = .7, val = .15, test = .15)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
x.train <- as.matrix(x$train)
x.val <- as.matrix(x$val)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.test <- as.matrix(y$test)
y.val <- as.matrix(y$val)
########Build Model
?glmnet
#base elastic net
elnet <- glmnet(x.train, y.train, family="mgaussian", alpha=.5, standardize = TRUE)
#ridge
ridge <- glmnet(x.train, y.train, family="mgaussian", alpha=0, standardize = TRUE)
# Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
for (i in 0:10) {
assign(paste("fit", i, sep=""), cv.glmnet(x.train, y.train, type.measure="mse",
alpha=i/10,family="gaussian"))
}
yhat0 <- predict(fit0, s=fit0$lambda.min, newx=x.val)
yhat1 <- predict(fit1, s=fit1$lambda.min, newx=x.val)
yhat2 <- predict(fit2, s=fit2$lambda.min, newx=x.val)
yhat3 <- predict(fit3, s=fit3$lambda.min, newx=x.val)
yhat4 <- predict(fit4, s=fit4$lambda.min, newx=x.val)
yhat5 <- predict(fit5, s=fit5$lambda.min, newx=x.val)
yhat6 <- predict(fit6, s=fit6$lambda.min, newx=x.val)
yhat7 <- predict(fit7, s=fit7$lambda.min, newx=x.val)
yhat8 <- predict(fit8, s=fit8$lambda.min, newx=x.val)
yhat9 <- predict(fit9, s=fit9$lambda.min, newx=x.val)
yhat10 <- predict(fit10, s=fit10$lambda.min, newx=x.val)
mse0 <- mean((y.val - yhat0)^2)
mse1 <- mean((y.val - yhat1)^2)
mse2 <- mean((y.val - yhat2)^2)
mse3 <- mean((y.val - yhat3)^2)
mse4 <- mean((y.val - yhat4)^2)
mse5 <- mean((y.val - yhat5)^2)
mse6 <- mean((y.val - yhat6)^2)
mse7 <- mean((y.val - yhat7)^2)
mse8 <- mean((y.val - yhat8)^2)
mse9 <- mean((y.val - yhat9)^2)
mse10 <- mean((y.val - yhat10)^2)
plot(c(mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit4)
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
elpred<-predict(fit0, s=fit0$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
#predict crime level in test city
new_crime = predict(fit0, s=fit0$lambda.min, newx=test_city)
new_crime
elpred<-predict(fit0, s=fit0$lambda.min, newx=x.test)
elpred
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
test_city <-t(test_city)
#predict crime level in test city
new_crime = predict(fit0, s=fit0$lambda.min, newx=test_city)
new_crime
elpred<-predict(fit0, s=fit0$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
elpred<-predict(fit0, s=fit0$lambda.1se, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
plot(fit0)
#split into training and test set
set.seed(42)
spec = c(train = .7, val = .15, test = .15)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
x.train <- as.matrix(x$train)
x.val <- as.matrix(x$val)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.test <- as.matrix(y$test)
y.val <- as.matrix(y$val)
#packages
library(glmnet)
library(ggplot2)
library(reshape2)
#set Directory to data path
setwd('/Users/dave/isye6501/Week_8')
#create table of crime data with headers
uscrimedata<-read.table("uscrime.txt", header = TRUE)
#Check class and inspect data
class(uscrimedata)
head(uscrimedata)
summary(uscrimedata)
#####Plotting and Data Cleaning
#####Outlier Testing - did not remove potential outliers based on week three analysis
#plot all variables
uscrime_melt = melt(data=uscrimedata, measure.vars = colnames(uscrimedata[,1:15]))
ggplot(data = uscrime_melt, aes(x=value, y=Crime)) +
geom_point() +
facet_wrap(~variable, scales = "free")
#convert to matrix for use with glm
x<-uscrimedata[,1:15]
y<-uscrimedata[,16]
#Scale Data
uscrimedata <- as.data.frame(scale(uscrimedata))
#split into training and test set
set.seed(42)
spec = c(train = .7, val = .15, test = .15)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
x.train <- as.matrix(x$train)
x.val <- as.matrix(x$val)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.test <- as.matrix(y$test)
y.val <- as.matrix(y$val)
########Build Model
?glmnet
#base elastic net
elnet <- glmnet(x.train, y.train, family="mgaussian", alpha=.5, standardize = TRUE)
#ridge
ridge <- glmnet(x.train, y.train, family="mgaussian", alpha=0, standardize = TRUE)
# Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
for (i in 0:10) {
assign(paste("fit", i, sep=""), cv.glmnet(x.train, y.train, type.measure="mse",
alpha=i/10,family="gaussian"))
}
yhat0 <- predict(fit0, s=fit0$lambda.min, newx=x.val)
yhat1 <- predict(fit1, s=fit1$lambda.min, newx=x.val)
yhat2 <- predict(fit2, s=fit2$lambda.min, newx=x.val)
yhat3 <- predict(fit3, s=fit3$lambda.min, newx=x.val)
yhat4 <- predict(fit4, s=fit4$lambda.min, newx=x.val)
yhat5 <- predict(fit5, s=fit5$lambda.min, newx=x.val)
yhat6 <- predict(fit6, s=fit6$lambda.min, newx=x.val)
yhat7 <- predict(fit7, s=fit7$lambda.min, newx=x.val)
yhat8 <- predict(fit8, s=fit8$lambda.min, newx=x.val)
yhat9 <- predict(fit9, s=fit9$lambda.min, newx=x.val)
yhat10 <- predict(fit10, s=fit10$lambda.min, newx=x.val)
mse0 <- mean((y.val - yhat0)^2)
mse1 <- mean((y.val - yhat1)^2)
mse2 <- mean((y.val - yhat2)^2)
mse3 <- mean((y.val - yhat3)^2)
mse4 <- mean((y.val - yhat4)^2)
mse5 <- mean((y.val - yhat5)^2)
mse6 <- mean((y.val - yhat6)^2)
mse7 <- mean((y.val - yhat7)^2)
mse8 <- mean((y.val - yhat8)^2)
mse9 <- mean((y.val - yhat9)^2)
mse10 <- mean((y.val - yhat10)^2)
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
#packages
library(glmnet)
library(ggplot2)
library(reshape2)
#set Directory to data path
setwd('/Users/dave/isye6501/Week_8')
#create table of crime data with headers
uscrimedata<-read.table("uscrime.txt", header = TRUE)
#Check class and inspect data
class(uscrimedata)
head(uscrimedata)
summary(uscrimedata)
#####Plotting and Data Cleaning
#####Outlier Testing - did not remove potential outliers based on week three analysis
#plot all variables
uscrime_melt = melt(data=uscrimedata, measure.vars = colnames(uscrimedata[,1:15]))
ggplot(data = uscrime_melt, aes(x=value, y=Crime)) +
geom_point() +
facet_wrap(~variable, scales = "free")
#convert to matrix for use with glm
x<-uscrimedata[,1:15]
y<-uscrimedata[,16]
#Scale Data
uscrimedata <- as.data.frame(scale(uscrimedata))
#split into training and test set
set.seed(1)
spec = c(train = .8, val = .1, test = .1)
g = sample(cut(
seq(nrow(x)),
nrow(x)*cumsum(c(0,spec)),
labels = names(spec)
))
x = split(x,g)
y = split(y,g)
x.train <- as.matrix(x$train)
x.val <- as.matrix(x$val)
x.test <- as.matrix(x$test)
y.train <- as.matrix(y$train)
y.val <- as.matrix(y$val)
y.test <- as.matrix(y$test)
########Build Model
?glmnet
#base elastic net
elnet <- glmnet(x.train, y.train, family="mgaussian", alpha=.5, standardize = TRUE)
#ridge
ridge <- glmnet(x.train, y.train, family="mgaussian", alpha=0, standardize = TRUE)
# Cross validation for each alpha = 0, 0.1, ... , 0.9, 1.0
for (i in 0:10) {
assign(paste("fit", i, sep=""), cv.glmnet(x.train, y.train, type.measure="mse",
alpha=i/10,family="gaussian"))
}
yhat0 <- predict(fit0, s=fit0$lambda.min, newx=x.val)
yhat1 <- predict(fit1, s=fit1$lambda.min, newx=x.val)
yhat2 <- predict(fit2, s=fit2$lambda.min, newx=x.val)
yhat3 <- predict(fit3, s=fit3$lambda.min, newx=x.val)
yhat4 <- predict(fit4, s=fit4$lambda.min, newx=x.val)
yhat5 <- predict(fit5, s=fit5$lambda.min, newx=x.val)
yhat6 <- predict(fit6, s=fit6$lambda.min, newx=x.val)
yhat7 <- predict(fit7, s=fit7$lambda.min, newx=x.val)
yhat8 <- predict(fit8, s=fit8$lambda.min, newx=x.val)
yhat9 <- predict(fit9, s=fit9$lambda.min, newx=x.val)
yhat10 <- predict(fit10, s=fit10$lambda.min, newx=x.val)
mse0 <- mean((y.val - yhat0)^2)
mse1 <- mean((y.val - yhat1)^2)
mse2 <- mean((y.val - yhat2)^2)
mse3 <- mean((y.val - yhat3)^2)
mse4 <- mean((y.val - yhat4)^2)
mse5 <- mean((y.val - yhat5)^2)
mse6 <- mean((y.val - yhat6)^2)
mse7 <- mean((y.val - yhat7)^2)
mse8 <- mean((y.val - yhat8)^2)
mse9 <- mean((y.val - yhat9)^2)
mse10 <- mean((y.val - yhat10)^2)
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit0)
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit0)
########Predict
#create test city data frame - do not use So as it was not used when creating principal components
test_city <- c(M = 14.0, So = 1,
Ed = 10.0, Po1 = 12.0,
Po2 = 15.5,LF = 0.640,
M.F = 94.0, Pop = 150,
NW = 1.1, U1 = 0.120,
U2 = 3.6, Wealth = 3200,
Ineq = 20.1, Prob = 0.04,
Time = 39.0)
test_city <-t(test_city)
#predict crime level in test city
new_crime = predict(fit0, s=fit0$lambda.min, newx=test_city)
new_crime
elpred<-predict(fit0, s=fit0$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
plot(fit4)
plot(c(mse0, mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(c(mse1,mse2,mse3,mse4,mse5,mse6,mse7,mse8,mse9, mse10), ylab = "MSE", xlab = "Model Alpha")
plot(fit4)
elpred<-predict(fit0, s=fit0$lambda.1se, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
elpred<-predict(fit0, s=log(4.2), newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
fit0$lambda.min
fit0$lambda.min
elpred<-predict(fit0, s=fit0$lambda.min, newx=x.test)
elpred
R2EL <- 1 - (sum((y.test-elpred )^2)/sum((y.test-mean(elpred))^2))
R2EL
